import { replaceParams } from './replace-params';
import { PluralForm } from './types';
import pluralizerEn from './plural/en';
import pluralizerRu from './plural/ru';
export * from './types';
export class I18N {
    constructor(options) {
        this.data = {};
        this.lang = undefined;
        this.pluralizers = {
            en: pluralizerEn,
            ru: pluralizerRu,
        };
        this.logger = null;
        this.logger = (options === null || options === void 0 ? void 0 : options.logger) || null;
    }
    setLang(lang) {
        this.lang = lang;
    }
    configurePluralization(pluralizers) {
        this.pluralizers = Object.assign({}, this.pluralizers, pluralizers);
    }
    registerKeyset(lang, keysetName, data = {}) {
        if (this.data[lang] && Object.prototype.hasOwnProperty.call(this.data[lang], keysetName)) {
            throw new Error(`Keyset '${keysetName}' is already registered, aborting!`);
        }
        this.data[lang] = Object.assign({}, this.data[lang], { [keysetName]: data });
    }
    registerKeysets(lang, data) {
        Object.keys(data).forEach((keysetName) => {
            this.registerKeyset(lang, keysetName, data[keysetName]);
        });
    }
    has(keysetName, key, lang) {
        const languageData = this.getLanguageData(lang);
        return Boolean(languageData && languageData[keysetName] && languageData[keysetName][key]);
    }
    i18n(keysetName, key, params) {
        const languageData = this.getLanguageData(this.lang);
        if (typeof languageData === 'undefined') {
            throw new Error(`Language '${this.lang}' is not defined, make sure you call setLang for the same language you called registerKeysets for!`);
        }
        if (Object.keys(languageData).length === 0) {
            this.warn('Language data is empty.');
            return key;
        }
        const keyset = languageData[keysetName];
        if (!keyset) {
            this.warn('Keyset not found.', keysetName);
            return key;
        }
        if (Object.keys(keyset).length === 0) {
            this.warn('Keyset is empty.', keysetName);
            return key;
        }
        const keyValue = keyset && keyset[key];
        let result;
        if (typeof keyValue === 'undefined') {
            this.warn('Missing key.', keysetName, key);
            return key;
        }
        if (Array.isArray(keyValue)) {
            if (keyValue.length < 3) {
                this.warn('Missing required plurals', keysetName, key);
                return key;
            }
            const count = Number(params === null || params === void 0 ? void 0 : params.count);
            if (Number.isNaN(count)) {
                this.warn('Missing params.count for key.', keysetName, key);
                return key;
            }
            const pluralizer = this.getLanguagePluralizer(this.lang);
            result = keyValue[pluralizer(count, PluralForm)] || keyValue[PluralForm.Many];
            if (keyValue[PluralForm.None] === undefined) {
                this.warn('Missing key for 0', keysetName, key);
            }
        }
        else {
            result = keyValue;
        }
        if (params) {
            result = replaceParams(result, params);
        }
        return result;
    }
    keyset(keysetName) {
        return (key, params) => {
            return this.i18n(keysetName, key, params);
        };
    }
    warn(msg, keyset, key) {
        var _a;
        let cacheKey = '';
        if (keyset) {
            cacheKey += keyset;
            if (key) {
                cacheKey += `.${key}`;
            }
        }
        else {
            cacheKey = 'languageData';
        }
        (_a = this.logger) === null || _a === void 0 ? void 0 : _a.log(`I18n: ${msg}`, {
            level: 'info',
            logger: cacheKey,
            extra: {
                type: 'i18n'
            }
        });
    }
    getLanguageData(lang) {
        const langCode = lang || this.lang;
        return langCode ? this.data[langCode] : undefined;
    }
    getLanguagePluralizer(lang) {
        const pluralizer = lang ? this.pluralizers[lang] : undefined;
        if (!pluralizer) {
            this.warn(`Pluralization is not configured for language '${lang}', falling back to the english ruleset`);
        }
        return pluralizer || pluralizerEn;
    }
}
