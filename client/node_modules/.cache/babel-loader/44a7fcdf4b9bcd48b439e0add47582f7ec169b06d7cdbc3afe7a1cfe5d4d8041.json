{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.formatToParts = exports.isFormatXMLElementFn = exports.PART_TYPE = void 0;\nvar icu_messageformat_parser_1 = require(\"@formatjs/icu-messageformat-parser\");\nvar error_1 = require(\"./error\");\nvar PART_TYPE;\n(function (PART_TYPE) {\n  PART_TYPE[PART_TYPE[\"literal\"] = 0] = \"literal\";\n  PART_TYPE[PART_TYPE[\"object\"] = 1] = \"object\";\n})(PART_TYPE || (exports.PART_TYPE = PART_TYPE = {}));\nfunction mergeLiteral(parts) {\n  if (parts.length < 2) {\n    return parts;\n  }\n  return parts.reduce(function (all, part) {\n    var lastPart = all[all.length - 1];\n    if (!lastPart || lastPart.type !== PART_TYPE.literal || part.type !== PART_TYPE.literal) {\n      all.push(part);\n    } else {\n      lastPart.value += part.value;\n    }\n    return all;\n  }, []);\n}\nfunction isFormatXMLElementFn(el) {\n  return typeof el === 'function';\n}\nexports.isFormatXMLElementFn = isFormatXMLElementFn;\n// TODO(skeleton): add skeleton support\nfunction formatToParts(els, locales, formatters, formats, values, currentPluralValue,\n// For debugging\noriginalMessage) {\n  // Hot path for straight simple msg translations\n  if (els.length === 1 && (0, icu_messageformat_parser_1.isLiteralElement)(els[0])) {\n    return [{\n      type: PART_TYPE.literal,\n      value: els[0].value\n    }];\n  }\n  var result = [];\n  for (var _i = 0, els_1 = els; _i < els_1.length; _i++) {\n    var el = els_1[_i];\n    // Exit early for string parts.\n    if ((0, icu_messageformat_parser_1.isLiteralElement)(el)) {\n      result.push({\n        type: PART_TYPE.literal,\n        value: el.value\n      });\n      continue;\n    }\n    // TODO: should this part be literal type?\n    // Replace `#` in plural rules with the actual numeric value.\n    if ((0, icu_messageformat_parser_1.isPoundElement)(el)) {\n      if (typeof currentPluralValue === 'number') {\n        result.push({\n          type: PART_TYPE.literal,\n          value: formatters.getNumberFormat(locales).format(currentPluralValue)\n        });\n      }\n      continue;\n    }\n    var varName = el.value;\n    // Enforce that all required values are provided by the caller.\n    if (!(values && varName in values)) {\n      throw new error_1.MissingValueError(varName, originalMessage);\n    }\n    var value = values[varName];\n    if ((0, icu_messageformat_parser_1.isArgumentElement)(el)) {\n      if (!value || typeof value === 'string' || typeof value === 'number') {\n        value = typeof value === 'string' || typeof value === 'number' ? String(value) : '';\n      }\n      result.push({\n        type: typeof value === 'string' ? PART_TYPE.literal : PART_TYPE.object,\n        value: value\n      });\n      continue;\n    }\n    // Recursively format plural and select parts' option — which can be a\n    // nested pattern structure. The choosing of the option to use is\n    // abstracted-by and delegated-to the part helper object.\n    if ((0, icu_messageformat_parser_1.isDateElement)(el)) {\n      var style = typeof el.style === 'string' ? formats.date[el.style] : (0, icu_messageformat_parser_1.isDateTimeSkeleton)(el.style) ? el.style.parsedOptions : undefined;\n      result.push({\n        type: PART_TYPE.literal,\n        value: formatters.getDateTimeFormat(locales, style).format(value)\n      });\n      continue;\n    }\n    if ((0, icu_messageformat_parser_1.isTimeElement)(el)) {\n      var style = typeof el.style === 'string' ? formats.time[el.style] : (0, icu_messageformat_parser_1.isDateTimeSkeleton)(el.style) ? el.style.parsedOptions : formats.time.medium;\n      result.push({\n        type: PART_TYPE.literal,\n        value: formatters.getDateTimeFormat(locales, style).format(value)\n      });\n      continue;\n    }\n    if ((0, icu_messageformat_parser_1.isNumberElement)(el)) {\n      var style = typeof el.style === 'string' ? formats.number[el.style] : (0, icu_messageformat_parser_1.isNumberSkeleton)(el.style) ? el.style.parsedOptions : undefined;\n      if (style && style.scale) {\n        value = value * (style.scale || 1);\n      }\n      result.push({\n        type: PART_TYPE.literal,\n        value: formatters.getNumberFormat(locales, style).format(value)\n      });\n      continue;\n    }\n    if ((0, icu_messageformat_parser_1.isTagElement)(el)) {\n      var children = el.children,\n        value_1 = el.value;\n      var formatFn = values[value_1];\n      if (!isFormatXMLElementFn(formatFn)) {\n        throw new error_1.InvalidValueTypeError(value_1, 'function', originalMessage);\n      }\n      var parts = formatToParts(children, locales, formatters, formats, values, currentPluralValue);\n      var chunks = formatFn(parts.map(function (p) {\n        return p.value;\n      }));\n      if (!Array.isArray(chunks)) {\n        chunks = [chunks];\n      }\n      result.push.apply(result, chunks.map(function (c) {\n        return {\n          type: typeof c === 'string' ? PART_TYPE.literal : PART_TYPE.object,\n          value: c\n        };\n      }));\n    }\n    if ((0, icu_messageformat_parser_1.isSelectElement)(el)) {\n      var opt = el.options[value] || el.options.other;\n      if (!opt) {\n        throw new error_1.InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);\n      }\n      result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values));\n      continue;\n    }\n    if ((0, icu_messageformat_parser_1.isPluralElement)(el)) {\n      var opt = el.options[\"=\".concat(value)];\n      if (!opt) {\n        if (!Intl.PluralRules) {\n          throw new error_1.FormatError(\"Intl.PluralRules is not available in this environment.\\nTry polyfilling it using \\\"@formatjs/intl-pluralrules\\\"\\n\", error_1.ErrorCode.MISSING_INTL_API, originalMessage);\n        }\n        var rule = formatters.getPluralRules(locales, {\n          type: el.pluralType\n        }).select(value - (el.offset || 0));\n        opt = el.options[rule] || el.options.other;\n      }\n      if (!opt) {\n        throw new error_1.InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);\n      }\n      result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values, value - (el.offset || 0)));\n      continue;\n    }\n  }\n  return mergeLiteral(result);\n}\nexports.formatToParts = formatToParts;","map":{"version":3,"names":["Object","defineProperty","exports","value","formatToParts","isFormatXMLElementFn","PART_TYPE","icu_messageformat_parser_1","require","error_1","mergeLiteral","parts","length","reduce","all","part","lastPart","type","literal","push","el","els","locales","formatters","formats","values","currentPluralValue","originalMessage","isLiteralElement","result","_i","els_1","isPoundElement","getNumberFormat","format","varName","MissingValueError","isArgumentElement","String","object","isDateElement","style","date","isDateTimeSkeleton","parsedOptions","undefined","getDateTimeFormat","isTimeElement","time","medium","isNumberElement","number","isNumberSkeleton","scale","isTagElement","children","value_1","formatFn","InvalidValueTypeError","chunks","map","p","Array","isArray","apply","c","isSelectElement","opt","options","other","InvalidValueError","keys","isPluralElement","concat","Intl","PluralRules","FormatError","ErrorCode","MISSING_INTL_API","rule","getPluralRules","pluralType","select","offset"],"sources":["/Users/ilaulanov/Documents/SynopsisYard/SYfood/client/node_modules/intl-messageformat/lib/src/formatters.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.formatToParts = exports.isFormatXMLElementFn = exports.PART_TYPE = void 0;\nvar icu_messageformat_parser_1 = require(\"@formatjs/icu-messageformat-parser\");\nvar error_1 = require(\"./error\");\nvar PART_TYPE;\n(function (PART_TYPE) {\n    PART_TYPE[PART_TYPE[\"literal\"] = 0] = \"literal\";\n    PART_TYPE[PART_TYPE[\"object\"] = 1] = \"object\";\n})(PART_TYPE || (exports.PART_TYPE = PART_TYPE = {}));\nfunction mergeLiteral(parts) {\n    if (parts.length < 2) {\n        return parts;\n    }\n    return parts.reduce(function (all, part) {\n        var lastPart = all[all.length - 1];\n        if (!lastPart ||\n            lastPart.type !== PART_TYPE.literal ||\n            part.type !== PART_TYPE.literal) {\n            all.push(part);\n        }\n        else {\n            lastPart.value += part.value;\n        }\n        return all;\n    }, []);\n}\nfunction isFormatXMLElementFn(el) {\n    return typeof el === 'function';\n}\nexports.isFormatXMLElementFn = isFormatXMLElementFn;\n// TODO(skeleton): add skeleton support\nfunction formatToParts(els, locales, formatters, formats, values, currentPluralValue, \n// For debugging\noriginalMessage) {\n    // Hot path for straight simple msg translations\n    if (els.length === 1 && (0, icu_messageformat_parser_1.isLiteralElement)(els[0])) {\n        return [\n            {\n                type: PART_TYPE.literal,\n                value: els[0].value,\n            },\n        ];\n    }\n    var result = [];\n    for (var _i = 0, els_1 = els; _i < els_1.length; _i++) {\n        var el = els_1[_i];\n        // Exit early for string parts.\n        if ((0, icu_messageformat_parser_1.isLiteralElement)(el)) {\n            result.push({\n                type: PART_TYPE.literal,\n                value: el.value,\n            });\n            continue;\n        }\n        // TODO: should this part be literal type?\n        // Replace `#` in plural rules with the actual numeric value.\n        if ((0, icu_messageformat_parser_1.isPoundElement)(el)) {\n            if (typeof currentPluralValue === 'number') {\n                result.push({\n                    type: PART_TYPE.literal,\n                    value: formatters.getNumberFormat(locales).format(currentPluralValue),\n                });\n            }\n            continue;\n        }\n        var varName = el.value;\n        // Enforce that all required values are provided by the caller.\n        if (!(values && varName in values)) {\n            throw new error_1.MissingValueError(varName, originalMessage);\n        }\n        var value = values[varName];\n        if ((0, icu_messageformat_parser_1.isArgumentElement)(el)) {\n            if (!value || typeof value === 'string' || typeof value === 'number') {\n                value =\n                    typeof value === 'string' || typeof value === 'number'\n                        ? String(value)\n                        : '';\n            }\n            result.push({\n                type: typeof value === 'string' ? PART_TYPE.literal : PART_TYPE.object,\n                value: value,\n            });\n            continue;\n        }\n        // Recursively format plural and select parts' option — which can be a\n        // nested pattern structure. The choosing of the option to use is\n        // abstracted-by and delegated-to the part helper object.\n        if ((0, icu_messageformat_parser_1.isDateElement)(el)) {\n            var style = typeof el.style === 'string'\n                ? formats.date[el.style]\n                : (0, icu_messageformat_parser_1.isDateTimeSkeleton)(el.style)\n                    ? el.style.parsedOptions\n                    : undefined;\n            result.push({\n                type: PART_TYPE.literal,\n                value: formatters\n                    .getDateTimeFormat(locales, style)\n                    .format(value),\n            });\n            continue;\n        }\n        if ((0, icu_messageformat_parser_1.isTimeElement)(el)) {\n            var style = typeof el.style === 'string'\n                ? formats.time[el.style]\n                : (0, icu_messageformat_parser_1.isDateTimeSkeleton)(el.style)\n                    ? el.style.parsedOptions\n                    : formats.time.medium;\n            result.push({\n                type: PART_TYPE.literal,\n                value: formatters\n                    .getDateTimeFormat(locales, style)\n                    .format(value),\n            });\n            continue;\n        }\n        if ((0, icu_messageformat_parser_1.isNumberElement)(el)) {\n            var style = typeof el.style === 'string'\n                ? formats.number[el.style]\n                : (0, icu_messageformat_parser_1.isNumberSkeleton)(el.style)\n                    ? el.style.parsedOptions\n                    : undefined;\n            if (style && style.scale) {\n                value =\n                    value *\n                        (style.scale || 1);\n            }\n            result.push({\n                type: PART_TYPE.literal,\n                value: formatters\n                    .getNumberFormat(locales, style)\n                    .format(value),\n            });\n            continue;\n        }\n        if ((0, icu_messageformat_parser_1.isTagElement)(el)) {\n            var children = el.children, value_1 = el.value;\n            var formatFn = values[value_1];\n            if (!isFormatXMLElementFn(formatFn)) {\n                throw new error_1.InvalidValueTypeError(value_1, 'function', originalMessage);\n            }\n            var parts = formatToParts(children, locales, formatters, formats, values, currentPluralValue);\n            var chunks = formatFn(parts.map(function (p) { return p.value; }));\n            if (!Array.isArray(chunks)) {\n                chunks = [chunks];\n            }\n            result.push.apply(result, chunks.map(function (c) {\n                return {\n                    type: typeof c === 'string' ? PART_TYPE.literal : PART_TYPE.object,\n                    value: c,\n                };\n            }));\n        }\n        if ((0, icu_messageformat_parser_1.isSelectElement)(el)) {\n            var opt = el.options[value] || el.options.other;\n            if (!opt) {\n                throw new error_1.InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);\n            }\n            result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values));\n            continue;\n        }\n        if ((0, icu_messageformat_parser_1.isPluralElement)(el)) {\n            var opt = el.options[\"=\".concat(value)];\n            if (!opt) {\n                if (!Intl.PluralRules) {\n                    throw new error_1.FormatError(\"Intl.PluralRules is not available in this environment.\\nTry polyfilling it using \\\"@formatjs/intl-pluralrules\\\"\\n\", error_1.ErrorCode.MISSING_INTL_API, originalMessage);\n                }\n                var rule = formatters\n                    .getPluralRules(locales, { type: el.pluralType })\n                    .select(value - (el.offset || 0));\n                opt = el.options[rule] || el.options.other;\n            }\n            if (!opt) {\n                throw new error_1.InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);\n            }\n            result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values, value - (el.offset || 0)));\n            continue;\n        }\n    }\n    return mergeLiteral(result);\n}\nexports.formatToParts = formatToParts;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}