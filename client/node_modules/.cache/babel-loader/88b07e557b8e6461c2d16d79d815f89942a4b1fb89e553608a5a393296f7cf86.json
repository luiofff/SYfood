{"ast":null,"code":"/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n    * Copyright 2020 Adobe. All rights reserved.\n    * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License. You may obtain a copy\n    * of the License at http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software distributed under\n    * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n    * OF ANY KIND, either express or implied. See the License for the specific language\n    * governing permissions and limitations under the License.\n    */let $488c6ddbf4ef74c2$var$formatterCache = new Map();\nlet $488c6ddbf4ef74c2$var$supportsSignDisplay = false;\ntry {\n  // @ts-ignore\n  $488c6ddbf4ef74c2$var$supportsSignDisplay = new Intl.NumberFormat(\"de-DE\", {\n    signDisplay: \"exceptZero\"\n  }).resolvedOptions().signDisplay === \"exceptZero\";\n  // eslint-disable-next-line no-empty\n} catch (e) {}\nlet $488c6ddbf4ef74c2$var$supportsUnit = false;\ntry {\n  // @ts-ignore\n  $488c6ddbf4ef74c2$var$supportsUnit = new Intl.NumberFormat(\"de-DE\", {\n    style: \"unit\",\n    unit: \"degree\"\n  }).resolvedOptions().style === \"unit\";\n  // eslint-disable-next-line no-empty\n} catch (e) {}\n// Polyfill for units since Safari doesn't support them yet. See https://bugs.webkit.org/show_bug.cgi?id=215438.\n// Currently only polyfilling the unit degree in narrow format for ColorSlider in our supported locales.\n// Values were determined by switching to each locale manually in Chrome.\nconst $488c6ddbf4ef74c2$var$UNITS = {\n  degree: {\n    narrow: {\n      default: \"\\xb0\",\n      \"ja-JP\": \" 度\",\n      \"zh-TW\": \"度\",\n      \"sl-SI\": \" \\xb0\"\n    }\n  }\n};\nclass $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5 {\n  /** Formats a number value as a string, according to the locale and options provided to the constructor. */format(value) {\n    let res = \"\";\n    if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) res = $488c6ddbf4ef74c2$export$711b50b3c525e0f2(this.numberFormatter, this.options.signDisplay, value);else res = this.numberFormatter.format(value);\n    if (this.options.style === \"unit\" && !$488c6ddbf4ef74c2$var$supportsUnit) {\n      var _UNITS_unit;\n      let {\n        unit: unit,\n        unitDisplay = \"short\",\n        locale: locale\n      } = this.resolvedOptions();\n      let values = (_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay];\n      res += values[locale] || values.default;\n    }\n    return res;\n  }\n  /** Formats a number to an array of parts such as separators, digits, punctuation, and more. */\n  formatToParts(value) {\n    // TODO: implement signDisplay for formatToParts\n    // @ts-ignore\n    return this.numberFormatter.formatToParts(value);\n  }\n  /** Formats a number range as a string. */\n  formatRange(start, end) {\n    // @ts-ignore\n    if (typeof this.numberFormatter.formatRange === \"function\")\n      // @ts-ignore\n      return this.numberFormatter.formatRange(start, end);\n    if (end < start) throw new RangeError(\"End date must be >= start date\");\n    // Very basic fallback for old browsers.\n    return `${this.format(start)} – ${this.format(end)}`;\n  }\n  /** Formats a number range as an array of parts. */\n  formatRangeToParts(start, end) {\n    // @ts-ignore\n    if (typeof this.numberFormatter.formatRangeToParts === \"function\")\n      // @ts-ignore\n      return this.numberFormatter.formatRangeToParts(start, end);\n    if (end < start) throw new RangeError(\"End date must be >= start date\");\n    let startParts = this.numberFormatter.formatToParts(start);\n    let endParts = this.numberFormatter.formatToParts(end);\n    return [...startParts.map(p => ({\n      ...p,\n      source: \"startRange\"\n    })), {\n      type: \"literal\",\n      value: \" – \",\n      source: \"shared\"\n    }, ...endParts.map(p => ({\n      ...p,\n      source: \"endRange\"\n    }))];\n  }\n  /** Returns the resolved formatting options based on the values passed to the constructor. */\n  resolvedOptions() {\n    let options = this.numberFormatter.resolvedOptions();\n    if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) options = {\n      ...options,\n      signDisplay: this.options.signDisplay\n    };\n    if (!$488c6ddbf4ef74c2$var$supportsUnit && this.options.style === \"unit\") options = {\n      ...options,\n      style: \"unit\",\n      unit: this.options.unit,\n      unitDisplay: this.options.unitDisplay\n    };\n    return options;\n  }\n  constructor(locale, options = {}) {\n    this.numberFormatter = $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options);\n    this.options = options;\n  }\n}\nfunction $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options = {}) {\n  let {\n    numberingSystem: numberingSystem\n  } = options;\n  if (numberingSystem && locale.indexOf(\"-u-nu-\") === -1) locale = `${locale}-u-nu-${numberingSystem}`;\n  if (options.style === \"unit\" && !$488c6ddbf4ef74c2$var$supportsUnit) {\n    var _UNITS_unit;\n    let {\n      unit: unit,\n      unitDisplay = \"short\"\n    } = options;\n    if (!unit) throw new Error('unit option must be provided with style: \"unit\"');\n    if (!((_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay])) throw new Error(`Unsupported unit ${unit} with unitDisplay = ${unitDisplay}`);\n    options = {\n      ...options,\n      style: \"decimal\"\n    };\n  }\n  let cacheKey = locale + (options ? Object.entries(options).sort((a, b) => a[0] < b[0] ? -1 : 1).join() : \"\");\n  if ($488c6ddbf4ef74c2$var$formatterCache.has(cacheKey)) return $488c6ddbf4ef74c2$var$formatterCache.get(cacheKey);\n  let numberFormatter = new Intl.NumberFormat(locale, options);\n  $488c6ddbf4ef74c2$var$formatterCache.set(cacheKey, numberFormatter);\n  return numberFormatter;\n}\nfunction $488c6ddbf4ef74c2$export$711b50b3c525e0f2(numberFormat, signDisplay, num) {\n  if (signDisplay === \"auto\") return numberFormat.format(num);else if (signDisplay === \"never\") return numberFormat.format(Math.abs(num));else {\n    let needsPositiveSign = false;\n    if (signDisplay === \"always\") needsPositiveSign = num > 0 || Object.is(num, 0);else if (signDisplay === \"exceptZero\") {\n      if (Object.is(num, -0) || Object.is(num, 0)) num = Math.abs(num);else needsPositiveSign = num > 0;\n    }\n    if (needsPositiveSign) {\n      let negative = numberFormat.format(-num);\n      let noSign = numberFormat.format(num);\n      // ignore RTL/LTR marker character\n      let minus = negative.replace(noSign, \"\").replace(/\\u200e|\\u061C/, \"\");\n      if ([...minus].length !== 1) console.warn(\"@react-aria/i18n polyfill for NumberFormat signDisplay: Unsupported case\");\n      let positive = negative.replace(noSign, \"!!!\").replace(minus, \"+\").replace(\"!!!\", noSign);\n      return positive;\n    } else return numberFormat.format(num);\n  }\n}\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nconst $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX = new RegExp(\"^.*\\\\(.*\\\\).*$\");\nconst $6c7bd7858deea686$var$NUMBERING_SYSTEMS = [\"latn\", \"arab\", \"hanidec\"];\nclass $6c7bd7858deea686$export$cd11ab140839f11d {\n  /**\n  * Parses the given string to a number. Returns NaN if a valid number could not be parsed.\n  */\n  parse(value) {\n    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).parse(value);\n  }\n  /**\n  * Returns whether the given string could potentially be a valid number. This should be used to\n  * validate user input as the user types. If a `minValue` or `maxValue` is provided, the validity\n  * of the minus/plus sign characters can be checked.\n  */\n  isValidPartialNumber(value, minValue, maxValue) {\n    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).isValidPartialNumber(value, minValue, maxValue);\n  }\n  /**\n  * Returns a numbering system for which the given string is valid in the current locale.\n  * If no numbering system could be detected, the default numbering system for the current\n  * locale is returned.\n  */\n  getNumberingSystem(value) {\n    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).options.numberingSystem;\n  }\n  constructor(locale, options = {}) {\n    this.locale = locale;\n    this.options = options;\n  }\n}\nconst $6c7bd7858deea686$var$numberParserCache = new Map();\nfunction $6c7bd7858deea686$var$getNumberParserImpl(locale, options, value) {\n  // First try the default numbering system for the provided locale\n  let defaultParser = $6c7bd7858deea686$var$getCachedNumberParser(locale, options);\n  // If that doesn't match, and the locale doesn't include a hard coded numbering system,\n  // try each of the other supported numbering systems until we find one that matches.\n  if (!locale.includes(\"-nu-\") && !defaultParser.isValidPartialNumber(value)) {\n    for (let numberingSystem of $6c7bd7858deea686$var$NUMBERING_SYSTEMS) if (numberingSystem !== defaultParser.options.numberingSystem) {\n      let parser = $6c7bd7858deea686$var$getCachedNumberParser(locale + (locale.includes(\"-u-\") ? \"-nu-\" : \"-u-nu-\") + numberingSystem, options);\n      if (parser.isValidPartialNumber(value)) return parser;\n    }\n  }\n  return defaultParser;\n}\nfunction $6c7bd7858deea686$var$getCachedNumberParser(locale, options) {\n  let cacheKey = locale + (options ? Object.entries(options).sort((a, b) => a[0] < b[0] ? -1 : 1).join() : \"\");\n  let parser = $6c7bd7858deea686$var$numberParserCache.get(cacheKey);\n  if (!parser) {\n    parser = new $6c7bd7858deea686$var$NumberParserImpl(locale, options);\n    $6c7bd7858deea686$var$numberParserCache.set(cacheKey, parser);\n  }\n  return parser;\n}\n// The actual number parser implementation. Instances of this class are cached\n// based on the locale, options, and detected numbering system.\nclass $6c7bd7858deea686$var$NumberParserImpl {\n  parse(value) {\n    // to parse the number, we need to remove anything that isn't actually part of the number, for example we want '-10.40' not '-10.40 USD'\n    let fullySanitizedValue = this.sanitize(value);\n    // Remove group characters, and replace decimal points and numerals with ASCII values.\n    fullySanitizedValue = $6c7bd7858deea686$var$replaceAll(fullySanitizedValue, this.symbols.group, \"\").replace(this.symbols.decimal, \".\").replace(this.symbols.minusSign, \"-\").replace(this.symbols.numeral, this.symbols.index);\n    let newValue = fullySanitizedValue ? +fullySanitizedValue : NaN;\n    if (isNaN(newValue)) return NaN;\n    // accounting will always be stripped to a positive number, so if it's accounting and has a () around everything, then we need to make it negative again\n    if (this.options.currencySign === \"accounting\" && $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX.test(value)) newValue = -1 * newValue;\n    // when reading the number, if it's a percent, then it should be interpreted as being divided by 100\n    if (this.options.style === \"percent\") {\n      newValue /= 100;\n      var _this_options_maximumFractionDigits;\n      // after dividing to get the percent value, javascript may get .0210999999 instead of .0211, so fix the number of fraction digits\n      newValue = +newValue.toFixed(((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) + 2);\n    }\n    return newValue;\n  }\n  sanitize(value) {\n    // Remove literals and whitespace, which are allowed anywhere in the string\n    value = value.replace(this.symbols.literals, \"\");\n    // Replace the ASCII minus sign with the minus sign used in the current locale\n    // so that both are allowed in case the user's keyboard doesn't have the locale's minus sign.\n    value = value.replace(\"-\", this.symbols.minusSign);\n    // In arab numeral system, their decimal character is 1643, but most keyboards don't type that\n    // instead they use the , (44) character or apparently the (1548) character.\n    if (this.options.numberingSystem === \"arab\") {\n      value = value.replace(\",\", this.symbols.decimal);\n      value = value.replace(String.fromCharCode(1548), this.symbols.decimal);\n      value = $6c7bd7858deea686$var$replaceAll(value, \".\", this.symbols.group);\n    }\n    // fr-FR group character is char code 8239, but that's not a key on the french keyboard,\n    // so allow 'period' as a group char and replace it with a space\n    if (this.options.locale === \"fr-FR\") value = $6c7bd7858deea686$var$replaceAll(value, \".\", String.fromCharCode(8239));\n    return value;\n  }\n  isValidPartialNumber(value, minValue = -Infinity, maxValue = Infinity) {\n    value = this.sanitize(value);\n    // Remove minus or plus sign, which must be at the start of the string.\n    if (value.startsWith(this.symbols.minusSign) && minValue < 0) value = value.slice(this.symbols.minusSign.length);else if (this.symbols.plusSign && value.startsWith(this.symbols.plusSign) && maxValue > 0) value = value.slice(this.symbols.plusSign.length);\n    // Numbers cannot start with a group separator\n    if (value.startsWith(this.symbols.group)) return false;\n    // Remove numerals, groups, and decimals\n    value = $6c7bd7858deea686$var$replaceAll(value, this.symbols.group, \"\").replace(this.symbols.numeral, \"\").replace(this.symbols.decimal, \"\");\n    // The number is valid if there are no remaining characters\n    return value.length === 0;\n  }\n  constructor(locale, options = {}) {\n    this.formatter = new Intl.NumberFormat(locale, options);\n    this.options = this.formatter.resolvedOptions();\n    this.symbols = $6c7bd7858deea686$var$getSymbols(this.formatter, this.options, options);\n  }\n}\nconst $6c7bd7858deea686$var$nonLiteralParts = new Set([\"decimal\", \"fraction\", \"integer\", \"minusSign\", \"plusSign\", \"group\"]);\n// This list is derived from https://www.unicode.org/cldr/charts/43/supplemental/language_plural_rules.html#comparison and includes\n// all unique numbers which we need to check in order to determine all the plural forms for a given locale.\n// See: https://github.com/adobe/react-spectrum/pull/5134/files#r1337037855 for used script\nconst $6c7bd7858deea686$var$pluralNumbers = [0, 4, 2, 1, 11, 20, 3, 7, 100, 21, 0.1, 1.1];\nfunction $6c7bd7858deea686$var$getSymbols(formatter, intlOptions, originalOptions) {\n  var _allParts_find, _posAllParts_find, _allParts_find1, _allParts_find2;\n  // Note: some locale's don't add a group symbol until there is a ten thousands place\n  let allParts = formatter.formatToParts(-10000.111);\n  let posAllParts = formatter.formatToParts(10000.111);\n  let pluralParts = $6c7bd7858deea686$var$pluralNumbers.map(n => formatter.formatToParts(n));\n  var _allParts_find_value;\n  let minusSign = (_allParts_find_value = (_allParts_find = allParts.find(p => p.type === \"minusSign\")) === null || _allParts_find === void 0 ? void 0 : _allParts_find.value) !== null && _allParts_find_value !== void 0 ? _allParts_find_value : \"-\";\n  let plusSign = (_posAllParts_find = posAllParts.find(p => p.type === \"plusSign\")) === null || _posAllParts_find === void 0 ? void 0 : _posAllParts_find.value;\n  // Safari does not support the signDisplay option, but our number parser polyfills it.\n  // If no plus sign was returned, but the original options contained signDisplay, default to the '+' character.\n  // @ts-ignore\n  if (!plusSign && ((originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === \"exceptZero\" || (originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === \"always\")) plusSign = \"+\";\n  let decimal = (_allParts_find1 = allParts.find(p => p.type === \"decimal\")) === null || _allParts_find1 === void 0 ? void 0 : _allParts_find1.value;\n  let group = (_allParts_find2 = allParts.find(p => p.type === \"group\")) === null || _allParts_find2 === void 0 ? void 0 : _allParts_find2.value;\n  // this set is also for a regex, it's all literals that might be in the string we want to eventually parse that\n  // don't contribute to the numerical value\n  let allPartsLiterals = allParts.filter(p => !$6c7bd7858deea686$var$nonLiteralParts.has(p.type)).map(p => $6c7bd7858deea686$var$escapeRegex(p.value));\n  let pluralPartsLiterals = pluralParts.flatMap(p => p.filter(p => !$6c7bd7858deea686$var$nonLiteralParts.has(p.type)).map(p => $6c7bd7858deea686$var$escapeRegex(p.value)));\n  let sortedLiterals = [...new Set([...allPartsLiterals, ...pluralPartsLiterals])].sort((a, b) => b.length - a.length);\n  let literals = sortedLiterals.length === 0 ? new RegExp(\"[\\\\p{White_Space}]\", \"gu\") : new RegExp(`${sortedLiterals.join(\"|\")}|[\\\\p{White_Space}]`, \"gu\");\n  // These are for replacing non-latn characters with the latn equivalent\n  let numerals = [...new Intl.NumberFormat(intlOptions.locale, {\n    useGrouping: false\n  }).format(9876543210)].reverse();\n  let indexes = new Map(numerals.map((d, i) => [d, i]));\n  let numeral = new RegExp(`[${numerals.join(\"\")}]`, \"g\");\n  let index = d => String(indexes.get(d));\n  return {\n    minusSign: minusSign,\n    plusSign: plusSign,\n    decimal: decimal,\n    group: group,\n    literals: literals,\n    numeral: numeral,\n    index: index\n  };\n}\nfunction $6c7bd7858deea686$var$replaceAll(str, find, replace) {\n  // @ts-ignore\n  if (str.replaceAll)\n    // @ts-ignore\n    return str.replaceAll(find, replace);\n  return str.split(find).join(replace);\n}\nfunction $6c7bd7858deea686$var$escapeRegex(string) {\n  return string.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n}\nexport { $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5 as NumberFormatter, $6c7bd7858deea686$export$cd11ab140839f11d as NumberParser };","map":{"version":3,"names":["$488c6ddbf4ef74c2$var$formatterCache","Map","$488c6ddbf4ef74c2$var$supportsSignDisplay","Intl","NumberFormat","signDisplay","resolvedOptions","e","$488c6ddbf4ef74c2$var$supportsUnit","style","unit","$488c6ddbf4ef74c2$var$UNITS","degree","narrow","default","$488c6ddbf4ef74c2$export$cc77c4ff7e8673c5","format","value","res","options","$488c6ddbf4ef74c2$export$711b50b3c525e0f2","numberFormatter","_UNITS_unit","unitDisplay","locale","values","formatToParts","formatRange","start","end","RangeError","formatRangeToParts","startParts","endParts","map","p","source","type","constructor","$488c6ddbf4ef74c2$var$getCachedNumberFormatter","numberingSystem","indexOf","Error","cacheKey","Object","entries","sort","a","b","join","has","get","set","numberFormat","num","Math","abs","needsPositiveSign","is","negative","noSign","minus","replace","length","console","warn","positive","$6c7bd7858deea686$var$CURRENCY_SIGN_REGEX","RegExp","$6c7bd7858deea686$var$NUMBERING_SYSTEMS","$6c7bd7858deea686$export$cd11ab140839f11d","parse","$6c7bd7858deea686$var$getNumberParserImpl","isValidPartialNumber","minValue","maxValue","getNumberingSystem","$6c7bd7858deea686$var$numberParserCache","defaultParser","$6c7bd7858deea686$var$getCachedNumberParser","includes","parser","$6c7bd7858deea686$var$NumberParserImpl","fullySanitizedValue","sanitize","$6c7bd7858deea686$var$replaceAll","symbols","group","decimal","minusSign","numeral","index","newValue","NaN","isNaN","currencySign","test","_this_options_maximumFractionDigits","toFixed","maximumFractionDigits","literals","String","fromCharCode","Infinity","startsWith","slice","plusSign","formatter","$6c7bd7858deea686$var$getSymbols","$6c7bd7858deea686$var$nonLiteralParts","Set","$6c7bd7858deea686$var$pluralNumbers","intlOptions","originalOptions","_allParts_find","_posAllParts_find","_allParts_find1","_allParts_find2","allParts","posAllParts","pluralParts","n","_allParts_find_value","find","allPartsLiterals","filter","$6c7bd7858deea686$var$escapeRegex","pluralPartsLiterals","flatMap","sortedLiterals","numerals","useGrouping","reverse","indexes","d","i","str","replaceAll","split","string"],"sources":["/Users/ilaulanov/Documents/SynopsisYard/SYfood/client/node_modules/@internationalized/number/dist/packages/@internationalized/number/src/index.ts","/Users/ilaulanov/Documents/SynopsisYard/SYfood/client/node_modules/@internationalized/number/dist/packages/@internationalized/number/src/NumberFormatter.ts","/Users/ilaulanov/Documents/SynopsisYard/SYfood/client/node_modules/@internationalized/number/dist/packages/@internationalized/number/src/NumberParser.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport type {NumberFormatOptions} from './NumberFormatter';\n\nexport {NumberFormatter} from './NumberFormatter';\nexport {NumberParser} from './NumberParser';\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nlet formatterCache = new Map<string, Intl.NumberFormat>();\n\nlet supportsSignDisplay = false;\ntry {\n  // @ts-ignore\n  supportsSignDisplay = (new Intl.NumberFormat('de-DE', {signDisplay: 'exceptZero'})).resolvedOptions().signDisplay === 'exceptZero';\n  // eslint-disable-next-line no-empty\n} catch (e) {}\n\nlet supportsUnit = false;\ntry {\n  // @ts-ignore\n  supportsUnit = (new Intl.NumberFormat('de-DE', {style: 'unit', unit: 'degree'})).resolvedOptions().style === 'unit';\n  // eslint-disable-next-line no-empty\n} catch (e) {}\n\n// Polyfill for units since Safari doesn't support them yet. See https://bugs.webkit.org/show_bug.cgi?id=215438.\n// Currently only polyfilling the unit degree in narrow format for ColorSlider in our supported locales.\n// Values were determined by switching to each locale manually in Chrome.\nconst UNITS = {\n  degree: {\n    narrow: {\n      default: '°',\n      'ja-JP': ' 度',\n      'zh-TW': '度',\n      'sl-SI': ' °'\n      // Arabic?? But Safari already doesn't use Arabic digits so might be ok...\n      // https://bugs.webkit.org/show_bug.cgi?id=218139\n    }\n  }\n};\n\nexport interface NumberFormatOptions extends Intl.NumberFormatOptions {\n  /** Overrides default numbering system for the current locale. */\n  numberingSystem?: string\n}\n\ninterface NumberRangeFormatPart extends Intl.NumberFormatPart {\n  source: 'startRange' | 'endRange' | 'shared'\n}\n\n/**\n * A wrapper around Intl.NumberFormat providing additional options, polyfills, and caching for performance.\n */\nexport class NumberFormatter implements Intl.NumberFormat {\n  private numberFormatter: Intl.NumberFormat;\n  private options: NumberFormatOptions;\n\n  constructor(locale: string, options: NumberFormatOptions = {}) {\n    this.numberFormatter = getCachedNumberFormatter(locale, options);\n    this.options = options;\n  }\n\n  /** Formats a number value as a string, according to the locale and options provided to the constructor. */\n  format(value: number): string {\n    let res = '';\n    if (!supportsSignDisplay && this.options.signDisplay != null) {\n      res = numberFormatSignDisplayPolyfill(this.numberFormatter, this.options.signDisplay, value);\n    } else {\n      res = this.numberFormatter.format(value);\n    }\n\n    if (this.options.style === 'unit' && !supportsUnit) {\n      let {unit, unitDisplay = 'short', locale} = this.resolvedOptions();\n      let values = UNITS[unit]?.[unitDisplay];\n      res += values[locale] || values.default;\n    }\n\n    return res;\n  }\n\n  /** Formats a number to an array of parts such as separators, digits, punctuation, and more. */\n  formatToParts(value: number): Intl.NumberFormatPart[] {\n    // TODO: implement signDisplay for formatToParts\n    // @ts-ignore\n    return this.numberFormatter.formatToParts(value);\n  }\n\n  /** Formats a number range as a string. */\n  formatRange(start: number, end: number): string {\n    // @ts-ignore\n    if (typeof this.numberFormatter.formatRange === 'function') {\n      // @ts-ignore\n      return this.numberFormatter.formatRange(start, end);\n    }\n\n    if (end < start) {\n      throw new RangeError('End date must be >= start date');\n    }\n\n    // Very basic fallback for old browsers.\n    return `${this.format(start)} – ${this.format(end)}`;\n  }\n\n  /** Formats a number range as an array of parts. */\n  formatRangeToParts(start: number, end: number): NumberRangeFormatPart[] {\n    // @ts-ignore\n    if (typeof this.numberFormatter.formatRangeToParts === 'function') {\n      // @ts-ignore\n      return this.numberFormatter.formatRangeToParts(start, end);\n    }\n\n    if (end < start) {\n      throw new RangeError('End date must be >= start date');\n    }\n\n    let startParts = this.numberFormatter.formatToParts(start);\n    let endParts = this.numberFormatter.formatToParts(end);\n    return [\n      ...startParts.map(p => ({...p, source: 'startRange'} as NumberRangeFormatPart)),\n      {type: 'literal', value: ' – ', source: 'shared'},\n      ...endParts.map(p => ({...p, source: 'endRange'} as NumberRangeFormatPart))\n    ];\n  }\n\n  /** Returns the resolved formatting options based on the values passed to the constructor. */\n  resolvedOptions(): Intl.ResolvedNumberFormatOptions {\n    let options = this.numberFormatter.resolvedOptions();\n    if (!supportsSignDisplay && this.options.signDisplay != null) {\n      options = {...options, signDisplay: this.options.signDisplay};\n    }\n\n    if (!supportsUnit && this.options.style === 'unit') {\n      options = {...options, style: 'unit', unit: this.options.unit, unitDisplay: this.options.unitDisplay};\n    }\n\n    return options;\n  }\n}\n\nfunction getCachedNumberFormatter(locale: string, options: NumberFormatOptions = {}): Intl.NumberFormat {\n  let {numberingSystem} = options;\n  if (numberingSystem && locale.indexOf('-u-nu-') === -1) {\n    locale = `${locale}-u-nu-${numberingSystem}`;\n  }\n\n  if (options.style === 'unit' && !supportsUnit) {\n    let {unit, unitDisplay = 'short'} = options;\n    if (!unit) {\n      throw new Error('unit option must be provided with style: \"unit\"');\n    }\n    if (!UNITS[unit]?.[unitDisplay]) {\n      throw new Error(`Unsupported unit ${unit} with unitDisplay = ${unitDisplay}`);\n    }\n    options = {...options, style: 'decimal'};\n  }\n\n  let cacheKey = locale + (options ? Object.entries(options).sort((a, b) => a[0] < b[0] ? -1 : 1).join() : '');\n  if (formatterCache.has(cacheKey)) {\n    return formatterCache.get(cacheKey);\n  }\n\n  let numberFormatter = new Intl.NumberFormat(locale, options);\n  formatterCache.set(cacheKey, numberFormatter);\n  return numberFormatter;\n}\n\n/** @private - exported for tests */\nexport function numberFormatSignDisplayPolyfill(numberFormat: Intl.NumberFormat, signDisplay: string, num: number) {\n  if (signDisplay === 'auto') {\n    return numberFormat.format(num);\n  } else if (signDisplay === 'never') {\n    return numberFormat.format(Math.abs(num));\n  } else {\n    let needsPositiveSign = false;\n    if (signDisplay === 'always') {\n      needsPositiveSign = num > 0 || Object.is(num, 0);\n    } else if (signDisplay === 'exceptZero') {\n      if (Object.is(num, -0) || Object.is(num, 0)) {\n        num = Math.abs(num);\n      } else {\n        needsPositiveSign = num > 0;\n      }\n    }\n\n    if (needsPositiveSign) {\n      let negative = numberFormat.format(-num);\n      let noSign = numberFormat.format(num);\n      // ignore RTL/LTR marker character\n      let minus = negative.replace(noSign, '').replace(/\\u200e|\\u061C/, '');\n      if ([...minus].length !== 1) {\n        console.warn('@react-aria/i18n polyfill for NumberFormat signDisplay: Unsupported case');\n      }\n      let positive = negative.replace(noSign, '!!!').replace(minus, '+').replace('!!!', noSign);\n      return positive;\n    } else {\n      return numberFormat.format(num);\n    }\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\ninterface Symbols {\n  minusSign: string,\n  plusSign: string,\n  decimal: string,\n  group: string,\n  literals: RegExp,\n  numeral: RegExp,\n  index: (v: string) => string\n}\n\nconst CURRENCY_SIGN_REGEX = new RegExp('^.*\\\\(.*\\\\).*$');\nconst NUMBERING_SYSTEMS = ['latn', 'arab', 'hanidec'];\n\n/**\n * A NumberParser can be used to perform locale-aware parsing of numbers from Unicode strings,\n * as well as validation of partial user input. It automatically detects the numbering system\n * used in the input, and supports parsing decimals, percentages, currency values, and units\n * according to the locale.\n */\nexport class NumberParser {\n  private locale: string;\n  private options: Intl.NumberFormatOptions;\n\n  constructor(locale: string, options: Intl.NumberFormatOptions = {}) {\n    this.locale = locale;\n    this.options = options;\n  }\n\n  /**\n   * Parses the given string to a number. Returns NaN if a valid number could not be parsed.\n   */\n  parse(value: string): number {\n    return getNumberParserImpl(this.locale, this.options, value).parse(value);\n  }\n\n  /**\n   * Returns whether the given string could potentially be a valid number. This should be used to\n   * validate user input as the user types. If a `minValue` or `maxValue` is provided, the validity\n   * of the minus/plus sign characters can be checked.\n   */\n  isValidPartialNumber(value: string, minValue?: number, maxValue?: number): boolean {\n    return getNumberParserImpl(this.locale, this.options, value).isValidPartialNumber(value, minValue, maxValue);\n  }\n\n  /**\n   * Returns a numbering system for which the given string is valid in the current locale.\n   * If no numbering system could be detected, the default numbering system for the current\n   * locale is returned.\n   */\n  getNumberingSystem(value: string): string {\n    return getNumberParserImpl(this.locale, this.options, value).options.numberingSystem;\n  }\n}\n\nconst numberParserCache = new Map<string, NumberParserImpl>();\nfunction getNumberParserImpl(locale: string, options: Intl.NumberFormatOptions, value: string) {\n  // First try the default numbering system for the provided locale\n  let defaultParser = getCachedNumberParser(locale, options);\n\n  // If that doesn't match, and the locale doesn't include a hard coded numbering system,\n  // try each of the other supported numbering systems until we find one that matches.\n  if (!locale.includes('-nu-') && !defaultParser.isValidPartialNumber(value)) {\n    for (let numberingSystem of NUMBERING_SYSTEMS) {\n      if (numberingSystem !== defaultParser.options.numberingSystem) {\n        let parser = getCachedNumberParser(locale + (locale.includes('-u-') ? '-nu-' : '-u-nu-') + numberingSystem, options);\n        if (parser.isValidPartialNumber(value)) {\n          return parser;\n        }\n      }\n    }\n  }\n\n  return defaultParser;\n}\n\nfunction getCachedNumberParser(locale: string, options: Intl.NumberFormatOptions) {\n  let cacheKey = locale + (options ? Object.entries(options).sort((a, b) => a[0] < b[0] ? -1 : 1).join() : '');\n  let parser = numberParserCache.get(cacheKey);\n  if (!parser) {\n    parser = new NumberParserImpl(locale, options);\n    numberParserCache.set(cacheKey, parser);\n  }\n\n  return parser;\n}\n\n// The actual number parser implementation. Instances of this class are cached\n// based on the locale, options, and detected numbering system.\nclass NumberParserImpl {\n  formatter: Intl.NumberFormat;\n  options: Intl.ResolvedNumberFormatOptions;\n  symbols: Symbols;\n\n  constructor(locale: string, options: Intl.NumberFormatOptions = {}) {\n    this.formatter = new Intl.NumberFormat(locale, options);\n    this.options = this.formatter.resolvedOptions();\n    this.symbols = getSymbols(this.formatter, this.options, options);\n  }\n\n  parse(value: string) {\n    // to parse the number, we need to remove anything that isn't actually part of the number, for example we want '-10.40' not '-10.40 USD'\n    let fullySanitizedValue = this.sanitize(value);\n\n    // Remove group characters, and replace decimal points and numerals with ASCII values.\n    fullySanitizedValue = replaceAll(fullySanitizedValue, this.symbols.group, '')\n      .replace(this.symbols.decimal, '.')\n      .replace(this.symbols.minusSign, '-')\n      .replace(this.symbols.numeral, this.symbols.index);\n\n    let newValue = fullySanitizedValue ? +fullySanitizedValue : NaN;\n    if (isNaN(newValue)) {\n      return NaN;\n    }\n\n    // accounting will always be stripped to a positive number, so if it's accounting and has a () around everything, then we need to make it negative again\n    if (this.options.currencySign === 'accounting' && CURRENCY_SIGN_REGEX.test(value)) {\n      newValue = -1 * newValue;\n    }\n\n    // when reading the number, if it's a percent, then it should be interpreted as being divided by 100\n    if (this.options.style === 'percent') {\n      newValue /= 100;\n      // after dividing to get the percent value, javascript may get .0210999999 instead of .0211, so fix the number of fraction digits\n      newValue = +newValue.toFixed((this.options.maximumFractionDigits ?? 0) + 2);\n    }\n\n    return newValue;\n  }\n\n  sanitize(value: string) {\n    // Remove literals and whitespace, which are allowed anywhere in the string\n    value = value.replace(this.symbols.literals, '');\n\n    // Replace the ASCII minus sign with the minus sign used in the current locale\n    // so that both are allowed in case the user's keyboard doesn't have the locale's minus sign.\n    value = value.replace('-', this.symbols.minusSign);\n\n    // In arab numeral system, their decimal character is 1643, but most keyboards don't type that\n    // instead they use the , (44) character or apparently the (1548) character.\n    if (this.options.numberingSystem === 'arab') {\n      value = value.replace(',', this.symbols.decimal);\n      value = value.replace(String.fromCharCode(1548), this.symbols.decimal);\n      value = replaceAll(value, '.', this.symbols.group);\n    }\n\n    // fr-FR group character is char code 8239, but that's not a key on the french keyboard,\n    // so allow 'period' as a group char and replace it with a space\n    if (this.options.locale === 'fr-FR') {\n      value = replaceAll(value, '.', String.fromCharCode(8239));\n    }\n\n    return value;\n  }\n\n  isValidPartialNumber(value: string, minValue: number = -Infinity, maxValue: number = Infinity): boolean {\n    value = this.sanitize(value);\n\n    // Remove minus or plus sign, which must be at the start of the string.\n    if (value.startsWith(this.symbols.minusSign) && minValue < 0) {\n      value = value.slice(this.symbols.minusSign.length);\n    } else if (this.symbols.plusSign && value.startsWith(this.symbols.plusSign) && maxValue > 0) {\n      value = value.slice(this.symbols.plusSign.length);\n    }\n\n    // Numbers cannot start with a group separator\n    if (value.startsWith(this.symbols.group)) {\n      return false;\n    }\n\n    // Remove numerals, groups, and decimals\n    value = replaceAll(value, this.symbols.group, '')\n      .replace(this.symbols.numeral, '')\n      .replace(this.symbols.decimal, '');\n\n    // The number is valid if there are no remaining characters\n    return value.length === 0;\n  }\n}\n\nconst nonLiteralParts = new Set(['decimal', 'fraction', 'integer', 'minusSign', 'plusSign', 'group']);\n\n// This list is derived from https://www.unicode.org/cldr/charts/43/supplemental/language_plural_rules.html#comparison and includes\n// all unique numbers which we need to check in order to determine all the plural forms for a given locale.\n// See: https://github.com/adobe/react-spectrum/pull/5134/files#r1337037855 for used script\nconst pluralNumbers = [\n  0, 4, 2, 1, 11, 20, 3, 7, 100, 21, 0.1, 1.1\n];\n\nfunction getSymbols(formatter: Intl.NumberFormat, intlOptions: Intl.ResolvedNumberFormatOptions, originalOptions: Intl.NumberFormatOptions): Symbols {\n  // Note: some locale's don't add a group symbol until there is a ten thousands place\n  let allParts = formatter.formatToParts(-10000.111);\n  let posAllParts = formatter.formatToParts(10000.111);\n  let pluralParts = pluralNumbers.map(n => formatter.formatToParts(n));\n\n  let minusSign = allParts.find(p => p.type === 'minusSign')?.value ?? '-';\n  let plusSign = posAllParts.find(p => p.type === 'plusSign')?.value;\n\n  // Safari does not support the signDisplay option, but our number parser polyfills it.\n  // If no plus sign was returned, but the original options contained signDisplay, default to the '+' character.\n  // @ts-ignore\n  if (!plusSign && (originalOptions?.signDisplay === 'exceptZero' || originalOptions?.signDisplay === 'always')) {\n    plusSign = '+';\n  }\n\n  let decimal = allParts.find(p => p.type === 'decimal')?.value;\n  let group = allParts.find(p => p.type === 'group')?.value;\n\n  // this set is also for a regex, it's all literals that might be in the string we want to eventually parse that\n  // don't contribute to the numerical value\n  let allPartsLiterals = allParts.filter(p => !nonLiteralParts.has(p.type)).map(p => escapeRegex(p.value));\n  let pluralPartsLiterals = pluralParts.flatMap(p => p.filter(p => !nonLiteralParts.has(p.type)).map(p => escapeRegex(p.value)));\n  let sortedLiterals = [...new Set([...allPartsLiterals, ...pluralPartsLiterals])].sort((a, b) => b.length - a.length);\n\n  let literals = sortedLiterals.length === 0 ? \n      new RegExp('[\\\\p{White_Space}]', 'gu') :\n      new RegExp(`${sortedLiterals.join('|')}|[\\\\p{White_Space}]`, 'gu');\n\n  // These are for replacing non-latn characters with the latn equivalent\n  let numerals = [...new Intl.NumberFormat(intlOptions.locale, {useGrouping: false}).format(9876543210)].reverse();\n  let indexes = new Map(numerals.map((d, i) => [d, i]));\n  let numeral = new RegExp(`[${numerals.join('')}]`, 'g');\n  let index = d => String(indexes.get(d));\n\n  return {minusSign, plusSign, decimal, group, literals, numeral, index};\n}\n\nfunction replaceAll(str: string, find: string, replace: string) {\n  // @ts-ignore\n  if (str.replaceAll) {\n    // @ts-ignore\n    return str.replaceAll(find, replace);\n  }\n\n  return str.split(find).join(replace);\n}\n\nfunction escapeRegex(string: string) {\n  return string.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}