{"ast":null,"code":"import { BORDER_WIDTH, POPUP_MIN_WIDTH_IN_VIRTUALIZE_CASE } from '../../constants';\nconst adjustBorderWidth = width => {\n  return width - BORDER_WIDTH * 2;\n};\nconst getMinWidth = (referenceWidth, virtualized) => {\n  if (virtualized) {\n    return referenceWidth > POPUP_MIN_WIDTH_IN_VIRTUALIZE_CASE ? referenceWidth : POPUP_MIN_WIDTH_IN_VIRTUALIZE_CASE;\n  }\n  return adjustBorderWidth(referenceWidth);\n};\nconst getPopupWidth = (width, controlWidth, virtualized) => {\n  let popupWidth = controlWidth;\n  if (typeof width === 'number') {\n    popupWidth = width;\n  } else if (width === 'fit') {\n    popupWidth = adjustBorderWidth(controlWidth);\n  } else {\n    popupWidth = getMinWidth(controlWidth, virtualized);\n  }\n  return `${popupWidth}px`;\n};\nexport const getModifiers = args => {\n  const {\n    width,\n    disablePortal,\n    virtualized\n  } = args;\n  // set popper width styles according anchor rect\n  const sameWidth = {\n    name: 'sameWidth',\n    enabled: true,\n    phase: 'beforeWrite',\n    requires: ['computeStyles'],\n    fn: ({\n      state,\n      name\n    }) => {\n      var _a;\n      // prevents styles applying after popup being opened (in case of multiple selection)\n      if ((_a = state.modifiersData[`${name}#persistent`]) === null || _a === void 0 ? void 0 : _a.skip) {\n        return;\n      }\n      const popupWidth = getPopupWidth(width, state.rects.reference.width, virtualized);\n      if (typeof width !== 'number' && width !== 'fit') {\n        state.styles.popper.minWidth = popupWidth;\n        state.styles.popper.width = undefined;\n      } else {\n        state.styles.popper.minWidth = popupWidth;\n        state.styles.popper.width = popupWidth;\n      }\n      state.styles.popper.maxWidth = `max(90vw, ${adjustBorderWidth(state.rects.reference.width)}px)`;\n      state.modifiersData[`${name}#persistent`] = {\n        skip: typeof width !== 'number'\n      };\n    },\n    effect: ({\n      state,\n      name\n    }) => {\n      // All this code is workaround. Check https://popper.js.org/docs/v2/modifiers/community-modifiers/\n      var _a;\n      // prevents styles applying after popup being opened (in case of multiple selection)\n      if ((_a = state.modifiersData[`${name}#persistent`]) === null || _a === void 0 ? void 0 : _a.skip) {\n        return;\n      }\n      const popupWidth = getPopupWidth(width, state.elements.reference.offsetWidth, virtualized);\n      if (typeof width !== 'number' && width !== 'fit') {\n        state.elements.popper.style.minWidth = popupWidth;\n      } else {\n        state.elements.popper.style.minWidth = popupWidth;\n        state.elements.popper.style.width = popupWidth;\n      }\n      state.elements.popper.style.maxWidth = `max(90vw, ${state.elements.reference.offsetWidth}px)`;\n    }\n  };\n  // prevents the popper from being cut off by moving it so that it stays visible within its boundary area\n  const preventOverflow = {\n    name: 'preventOverflow',\n    options: {\n      padding: 10,\n      altBoundary: disablePortal,\n      altAxis: true\n    }\n  };\n  return [sameWidth, preventOverflow];\n};","map":{"version":3,"names":["BORDER_WIDTH","POPUP_MIN_WIDTH_IN_VIRTUALIZE_CASE","adjustBorderWidth","width","getMinWidth","referenceWidth","virtualized","getPopupWidth","controlWidth","popupWidth","getModifiers","args","disablePortal","sameWidth","name","enabled","phase","requires","fn","state","_a","modifiersData","skip","rects","reference","styles","popper","minWidth","undefined","maxWidth","effect","elements","offsetWidth","style","preventOverflow","options","padding","altBoundary","altAxis"],"sources":["/Users/ilaulanov/Documents/SynopsisYard/SYfood/client/node_modules/@gravity-ui/uikit/build/esm/components/Select/components/SelectPopup/modifiers.js"],"sourcesContent":["import { BORDER_WIDTH, POPUP_MIN_WIDTH_IN_VIRTUALIZE_CASE } from '../../constants';\nconst adjustBorderWidth = (width) => {\n    return width - BORDER_WIDTH * 2;\n};\nconst getMinWidth = (referenceWidth, virtualized) => {\n    if (virtualized) {\n        return referenceWidth > POPUP_MIN_WIDTH_IN_VIRTUALIZE_CASE\n            ? referenceWidth\n            : POPUP_MIN_WIDTH_IN_VIRTUALIZE_CASE;\n    }\n    return adjustBorderWidth(referenceWidth);\n};\nconst getPopupWidth = (width, controlWidth, virtualized) => {\n    let popupWidth = controlWidth;\n    if (typeof width === 'number') {\n        popupWidth = width;\n    }\n    else if (width === 'fit') {\n        popupWidth = adjustBorderWidth(controlWidth);\n    }\n    else {\n        popupWidth = getMinWidth(controlWidth, virtualized);\n    }\n    return `${popupWidth}px`;\n};\nexport const getModifiers = (args) => {\n    const { width, disablePortal, virtualized } = args;\n    // set popper width styles according anchor rect\n    const sameWidth = {\n        name: 'sameWidth',\n        enabled: true,\n        phase: 'beforeWrite',\n        requires: ['computeStyles'],\n        fn: ({ state, name }) => {\n            var _a;\n            // prevents styles applying after popup being opened (in case of multiple selection)\n            if ((_a = state.modifiersData[`${name}#persistent`]) === null || _a === void 0 ? void 0 : _a.skip) {\n                return;\n            }\n            const popupWidth = getPopupWidth(width, state.rects.reference.width, virtualized);\n            if (typeof width !== 'number' && width !== 'fit') {\n                state.styles.popper.minWidth = popupWidth;\n                state.styles.popper.width = undefined;\n            }\n            else {\n                state.styles.popper.minWidth = popupWidth;\n                state.styles.popper.width = popupWidth;\n            }\n            state.styles.popper.maxWidth = `max(90vw, ${adjustBorderWidth(state.rects.reference.width)}px)`;\n            state.modifiersData[`${name}#persistent`] = {\n                skip: typeof width !== 'number',\n            };\n        },\n        effect: ({ state, name }) => {\n            // All this code is workaround. Check https://popper.js.org/docs/v2/modifiers/community-modifiers/\n            var _a;\n            // prevents styles applying after popup being opened (in case of multiple selection)\n            if ((_a = state.modifiersData[`${name}#persistent`]) === null || _a === void 0 ? void 0 : _a.skip) {\n                return;\n            }\n            const popupWidth = getPopupWidth(width, state.elements.reference.offsetWidth, virtualized);\n            if (typeof width !== 'number' && width !== 'fit') {\n                state.elements.popper.style.minWidth = popupWidth;\n            }\n            else {\n                state.elements.popper.style.minWidth = popupWidth;\n                state.elements.popper.style.width = popupWidth;\n            }\n            state.elements.popper.style.maxWidth = `max(90vw, ${state.elements.reference.offsetWidth}px)`;\n        },\n    };\n    // prevents the popper from being cut off by moving it so that it stays visible within its boundary area\n    const preventOverflow = {\n        name: 'preventOverflow',\n        options: { padding: 10, altBoundary: disablePortal, altAxis: true },\n    };\n    return [sameWidth, preventOverflow];\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}